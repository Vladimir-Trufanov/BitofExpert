## [Разбираемся с выделенной памятью для задачи](#)

> !!! 2024-11-01 - так и не удалось программно опускать и поднимать стек! Изыскания закончил!

ESP32 - это автономная электронная плата на двух процессорах от Espressif,  и размещённая на одной интегральной схеме с установленной многозадачной операционной системой FreeRTOS. 

Задачи, помещенные в операционную систему, должны совместно использовать ядра процессора. Для этого FreeRTOS делит время на тики. Задача может беспрепятственно использовать процессор в течение одного тика. По истечении тика система проверяет, не требуется ли выполнение другой задачи - [Using FreeRTOS with ESP32 and Arduino](https://wolles-elektronikkiste.de/en/using-freertos-with-esp32-and-arduino).

На ESP32 тактовая частота по умолчанию составляет 1 миллисекунду, которую можно проверить с помощью Serial.println(portTICK_PERIOD_MS). Другими словами, частота тактовых импульсов составляет 1 кГц. Можно запросить частоту тактовых импульсов с помощью Serial.println(configTICK_RATE_HZ).

Версия FreeRTOS для Arduino на базе AVR определяет частоту тактовых импульсов по умолчанию 62 Гц, то есть длительность тактового импульса составляет примерно 16 миллисекунд.

#### Какое ядро следует использовать?

По умолчанию код Arduino выполняется на ядре 1. Если используется Wi-Fi или BLE, в фоновом режиме выполняется много работы, которая осуществляется на ядре 0. Если назначить ядру 0 слишком много дополнительных задач, Wi-Fi и BLE могут перестать работать стабильно. 

Если не используются эти возможности, то выбор ядер для задач равнозначен.

#### Определение требований к объему памяти для задачи FreeRTOS

Stack (стек) забирает в себя локальные переменные и аргументы функций. Размер его меняется во время выполнения программы, он растёт от конца области памяти в сторону уменьшения адресов, навстречу куче. Программа сама выделяет память (при создании локальной переменной) и сама эту память освобождает (локальная переменная удаляется при выходе из функции). 

> ***Процессор не контролирует размер стека, то есть во время работы стек может врезаться в кучу и перезаписать находящиеся там данные.***

Функция  ***malloc()***  выделяет заданное количество байт динамической памяти в куче и возвращает адрес на первый байт выделенной области. Если свободной памяти недостаточно для выделения - возвращает "нулевой указатель" - NULL (nullptr).

В следующем скетче вычисляется объем памяти (стека), требующийся для задачи. Так как скетч подготовлен для ESP32-CAM, то для эксперимента используется контрольный светодиод и вспышка со своими штатными контактами 4 и 33.

При объявлении задач резервируется достаточный объем памяти (но различный для каждой задачи для пущей убедительности), а затем используется функция uxTaskGetStackHighWaterMark() для запроса оставшейся свободной памяти в зарезервированной области. 

Чтобы сообщить функции, uxTaskGetStackHighWaterMark() по какой задаче мы хотим определить свободную память, мы передаем ей дескриптор этой задачи (дескрипторы задач были определены ранее с помощью TaskHandle_t name и назначаете своим задачам в xTaskCreate().

> Следует заметить, что при реализации запроса  о требованиях к памяти внутри исследуемой задачи, это привело бы к неточному результату. Поэтому запрос по памяти выделен в отдельную задачу.

!!! В представленном скетче так же выводится в последовательный порт наименование задачи  с помощью функции pcTaskGetName().

При достаточном уменьшении размера стека вызывается перезапуск контроллера со следующей ошибкой:

```
Guru Meditation Error: Core  0 panic'ed (Unhandled debug exception). 
Debug exception reason: Stack canary watchpoint triggered. 
```

#### [ Скетч "Вычислить объем памяти (стека), требующийся для задачи"](high-watermark/high-watermark.ino)

### Библиография

#### [Распределение памяти в ESP32](https://kotyara12.ru/iot/esp32_memory/)

#### [Что работает быстрее: цикл или рекурсия? Измеряем производительность](https://dzen.ru/a/X9_vhyfOmCRaihka)

###### [в начало](#)
