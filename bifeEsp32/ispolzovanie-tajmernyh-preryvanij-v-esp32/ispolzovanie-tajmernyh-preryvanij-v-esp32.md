## [Использование таймерных прерываний в Esp32](#)

Данный материал опирается на документацию ESPRESSIF по таймерам [https://docs.espressif.com/projects/arduino-esp32/en/latest/api/timer.html](https://docs.espressif.com/projects/arduino-esp32/en/latest/api/timer.html).

В контроллерах ESP32 содержится от 2 до 4 аппаратных таймеров. Все они представляют собой 64-битные (54-битные для ESP32-C3) универсальные таймеры на основе 16-битных предварительных масштабирующих устройств и 64-битных (54-битных для ESP32-C3) счётчиков с возможностью автоматической перезагрузки.

```
Контроллер ESP32       Количество таймеров
------------------------------------------
ESP32                  4
ESP32-S2               4
ESP32-S3               4
ESP32-C3               2
ESP32-C6               2
ESP32-H2               2
```

#### Что такое "спин-блокировки"?

В представленном далее примере обработчик прерывания от таймера содержит критическую секцию, связанную со "спин-блокировкой" процессора (ядра). 

При использовании обычных блокировок (мьютексов) операционная система переводит ваш поток в состояние WAIT и прерывает его ("вытесняет задачу", планируя другие потоки на том же ядре. Это снижает производительность, ***когда время ожидания очень короткое***, потому что теперь ваш поток должен ждать прерывания, чтобы снова получить процессорное время. Кроме этого затрачиваются накладные расходы на переключение задач.

Спин-блокировки ([спинлоки](https://ru.wikipedia.org/wiki/Спин-блокировка)) не вызывают вытеснения потока, а заставляют его ждать в цикле ("спине"), пока ядро не снимет блокировку. То есть задача продолжает работать в кванте, выделенном ей операционной системой. 

Cпин-блокировки полезны только в тех местах, где время ожидания меньше кванта (читай: миллисекунд). Если время ожидания неизвестно, то спин-блокировки неэффективны, так как потребляется 100% процессорного времени на ожидающем ядре при выполнении проверки, доступна ли спин-блокировка. Это не позволяет другим потокам работать на этом ядре до истечения кванта времени. 

#### Критические разделы и отключение прерываний

В стандартной версии FreeRTOS критические секции реализованы с помощью ***taskENTER_CRITICAL()*** и ***portDISABLE_INTERRUPTS()*** вызовов. Это предотвращает принудительное переключение контекста и обслуживание ISR во время критической секции. Таким образом, критические секции используются в стандартной версии FreeRTOS в качестве надёжного метода защиты от одновременного доступа.

[Но в ESP32/8266 нет аппаратного метода, с помощью которого ядра могли бы отключать прерывания друг друга](https://docs.espressif.com/projects/esp-idf/en/v4.3.1/esp32/api-guides/freertos-smp.html). Вызов portDISABLE_INTERRUPTS() не повлияет на прерывания другого ядра. Таким образом, отключение прерываний НЕ является эффективным методом защиты от одновременного доступа к общим данным, поскольку другое ядро может свободно обращаться к данным, даже если текущее ядро отключило собственные прерывания.

По этой причине в ESP FreeRTOS критические секции реализуются с помощью специальных мьютексов, на которые ссылаются объекты ***portMUX_Type***. Они реализованы на основе специального компонента ***спин-блокировки***. При вызове ***taskENTER_CRITICAL*** или*** taskEXIT_CRITICAL*** в качестве аргумента передаётся объект спин-блокировки, который связан с общим ресурсом, требующим защиты доступа. 

При входе в критическую секцию в ESP вызывающее ядро отключает прерывания, как и в стандартной реализации FreeRTOS, а затем получает спин-блокировку и входит в критическую секцию. На этом этапе другое ядро не затронуто, если только оно не входит в свою собственную критическую секцию и не пытается получить ту же спин-блокировку. В этом случае оно будет ожидать освобождения блокировки. Таким образом, реализация критических секций в ESP32/8266 FreeRTOS позволяет ядру получить защищённый доступ к общему ресурсу, не отключая другое ядро. Другое ядро будет затронуто только в том случае, если оно попытается одновременно получить доступ к тому же ресурсу.

Для обслуживания критического раздела ESP-IDF FreeRTOS отделяются функции для обработчиков прерываний и в составе задач и выделяются в группы следующим образом: 

taskENTER_CRITICAL(mux), taskENTER_CRITICAL_ISR(mux), portENTER_CRITICAL(mux), portENTER_CRITICAL_ISR(mux) определены для вызова внутренней функции ***vPortEnterCritical()***

taskEXIT_CRITICAL(mux), taskEXIT_CRITICAL_ISR(mux), portEXIT_CRITICAL(mux), portEXIT_CRITICAL_ISR(mux) определены для вызова внутренней функции ***vPortExitCritical()***

portENTER_CRITICAL_SAFE(mux), portEXIT_CRITICAL_SAFE(mux) определяют ***контекст выполнения***, то есть ISR или Non-ISR и вызывают соответствующие функции критического раздела (port*_CRITICAL в Non-ISR и port*_CRITICAL_ISR в ISR).

Следует отметить, что при изменении стандартного кода FreeRTOS для обеспечения совместимости с ESP-IDF FreeRTOS можно легко изменить тип вызываемого критического раздела, поскольку все они определены для вызова одной и той же функции. Пока при входе и выходе используется одна и та же спин-блокировка, точный макрос или функция, используемые для вызова, не имеют значения.

#### [Пример таймера повтора](RepeatTimer/RepeatTimer.ino)

### Библиография

#### [----Использование семафоров и мьютексов в FreeRTOS на Arduino Uno](https://microkontroller.ru/arduino-projects/ispolzovanie-semaforov-i-myuteksov-v-freertos-na-arduino-uno/)



###### [в начало](#kvizzy)

0

1

2

3

4

5

6

7

8

9

0

1

2

3

4

5




