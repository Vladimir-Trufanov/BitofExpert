## [Обнаружение блокировки ESP32 с помощью внутреннего сторожевого таймера](https://github.com/TronixLab/ESP32_Watchdog?tab=readme-ov-file)

### I. Введение

> В материале представлен перевод github-репозитария [https://github.com/TronixLab/ESP32_Watchdog?tab=readme-ov-file](https://github.com/TronixLab/ESP32_Watchdog?tab=readme-ov-file).

> Все примеры реализованы для плат ESP32 в версии библиотеки от Espressif Systems версии 3.0.6 и проверены на контроллере AI-Thinker ESP32-CAM.

Если ваша программа по какой-либо причине зависает, самый быстрый способ восстановления - перезагрузить компьютер. Одним из наиболее известных примеров был фатальный сбой операционной системы Windows и отображение синего экрана смерти (BSoD), после чего компьютер перезагружался, чтобы избежать дальнейшего повреждения. 

В отличие от настольных компьютеров, встроенные устройства должны быть автономными. Что делать, если вы не можете перезагрузить компьютер физически? Если программа зависает, не всегда возможно дождаться, пока кто-нибудь eё перезагрузит. Некоторые встроенные устройства, такие как космические зонды, просто недоступны для людей, и ручной сброс невозможен; они могут стать необратимо отключенными, если не смогут автономно восстанавливаться после сбоев. 

В таких ситуациях сторожевой таймер Watchdog почти единственный способ спасти положение. 

### II. Что такое сторожевой таймер?

Сторожевой таймер (WDT) - это аппаратный или программный таймер, который может использоваться для автоматического обнаружения программных аномалий и автоматической генерации сброса системы, если основная программа пренебрегает его периодическим обслуживанием. 

Он часто используется для автоматического сброса встроенного устройства, зависшего из-за программного или аппаратного сбоя. 

> ***Сторожевой таймер основан на счетчике, который ведет обратный отсчет от некоторого начального значения до нуля. Встроенное программное обеспечение выбирает начальное значение счетчика и периодически перезапускает его. Если счетчик когда-либо достигает нуля до того, как программное обеспечение перезапустит его, предполагается, что программное обеспечение неисправно, и устанавливается сигнал сброса процессора.***

Процесс перезапуска счетчика (сброса) сторожевого таймера иногда называют словосочетанием ***“пинать собаку”***. Подходящей визуальной метафорой является изображение человека, на которого нападает злобная собака. Если он продолжает пинать собаку, она никогда не сможет его укусить. Но он должен продолжать пинать собаку через равные промежутки времени, чтобы избежать укуса. 

Аналогично, программное обеспечение должно регулярно перезапускать (сбрасывать) сторожевой таймер, иначе возникает риск перезапуска. Другой термин для обозначения “пинка” - это ***"подача сторожевого таймера"***. На сторожевой таймер непрерывно подается начальное значение, так что значение таймера никогда не может достичь нуля.

![Рис.1 Типичная настройка сторожевого таймера](A-typical-Watchdog-setup.jpg)

На [рис.1](#) показано типичное расположение сторожевого таймера как внешнего блока по отношению к процессору. Однако он также может быть встроен в тот же чип, что и центральный процессор. Это делается во многих микроконтроллерах. В любом случае выходной сигнал сторожевого таймера напрямую связан с сигналом сброса процессора.

#### [Учебный пример таймера сторожевого механизма](ex3-0-6_0_Watchdog/ex3-0-6_0_Watchdog.ino)

#### [Скетч "Базовый сторожевой таймер"](ex3-0-6_1_BasicWDT/ex3-0-6_1_BasicWDT.ino)

### III. Каковы потенциальные причины события зависания?

Выход из строя микроконтроллера - MCU, как неисправность железа, так и неучтеные ситуации в программном коде могут привести к полной остановке работы. Это может доставить неудобства пользователям или создать угрозу функциональной безопасности в критически важных приложениях. 

Механизм безопасности чрезвычайно важен. Надежная встраиваемая система требует совместных усилий разработчика оборудования и программиста встроенного программного обеспечения. Существуют аппаратные и программные факторы, из-за которых MCU может отказать:

- электрический шум может вызвать сбой питания и повредить часть программного обеспечения;
- нестабильный источник питания;
- переполнение стека памяти;
- отсутствие ответа на запрос у аппаратного компонента;
- обратная ЭДС, электромагнитные помехи, электростатический разряд, космические лучи и т.д.;
- состояние мертвой блокировки;
- множественные прерывания основного цикла.

!!! В следующем примере показано зависание -  явление, при котором две задачи находятся в заблокированном состоянии, одновременно ожидая доступа к ресурсам, которые удерживаются одной из них. 

!!! Во FreeRTOS нет решения проблемы зависания. При использовании этой операционной системы реального времени такого зависания можно избежать только путём тщательного программирования приложений. Следует составлять задачи таким образом, чтобы не возникало взаимоблокировки.

> ***Замечание от 2024-11-04: на сегодня, в версии библиотеки от Espressif Systems версии 3.0.6 и по итогам проверки на контроллере AI-Thinker ESP32-CAM проблема взаимоблокировки во  FreeRTOS разрешается, а сторожевой таймер при необходимости перезагружает контроллер!***

#### [Скетч "Взаимоблокировка"](ex3-0-6_2_DeadLockWDT/ex3-0-6_2_DeadLockWDT.ino)

### IV. Структура сторожевого таймера

Если пинать собаку через равные промежутки времени, это доказывает, что программное обеспечение работает. Часто бывает полезно пинать собаку только в том случае, если система проходит проверку работоспособности, как показано на рис. 2: основная программа обычно содержит цикл, который постоянно выполняется и выполняет различные функции. Таймер сторожевого пса загружается начальным значением, превышающим максимальную задержку выполнения основного цикла программы. Каждый раз, когда основной цикл выполняется, код сбрасывает таймер сторожевого пса («пинает» или «кормит» собаку). Если возникает ошибка и основная программа не возвращается для сброса таймера до того, как он обнулится, генерируется прерывание для сброса процессора. При таком использовании сторожевой таймер может обнаруживать ошибки в программе Arduino, работающей без присмотра, и предпринимать корректирующие действия с помощью сброса [5]. Лучший пример такой структуры показан в Листинге 1.

![Рис.2 Простая проверка работоспособности](prostaya-proverka-rabotosposobnosti.jpg)

В некоторых случаях перед тем, как запустить сторожевой таймер, необходимо выделить некоторые буферы или проверить состояние какого-либо компонента. Грамотное проектирование таких проверок увеличит количество ошибок, которые обнаружит сторожевой таймер. Один из подходов заключается в том, чтобы очищать некоторые флаги перед запуском каждого цикла, как показано на рис. 3.

![Рис.3 Проверка работоспособности с несколькими флагами в одном цикле](proverka-rabotosposobnosti-s-neskolkimi-flagami-v-odnom-cikle.jpg)

Каждый флаг устанавливается в определённой точке цикла. В конце цикла собаку пинают, но сначала проверяют флаги, чтобы убедиться, что все важные точки цикла были посещены. Структура показана на рис. 3 и может быть продемонстрирована в примере 3.

#### [Скетч "Проверка работоспособности в одном цикле"](ex3-0-6_3_SanityCheckSingleLoop/ex3-0-6_3_SanityCheckSingleLoop.ino)



### IV. "Всеобъемлющий сторожевой пес"

WDT является последней линией защиты, его конструкция должна предусматривать любой возможный сбой. 

Основные характеристики надёжного сторожевого устройства:

```
WDT должен быть независимым от центрального процессора;
WDT должен всегда, при любых условиях, за исключением, возможно, аппаратного сбоя, возвращать систему к жизни.
-------------------------------------------------------
Как вариант, некоторые WDT выдают не маскируемое прерывание (NMI) вместо сброса.
```
В следующем примере, сторожевой таймер - "всеобъемлющий сторожевой пес" обслуживает четыре задачи и вызывает перезагрузку контроллера, когда зацикливаются все задачи (при других обстоятельствах, можно было бы перезагружать контроллер при отдельном зависании любой задачи).

В примере тайм-аут сторожевого таймера выбран таким образом, чтобы все обычные задачи успевали последовательно выполнить один полный цикл от начальной точки до конечной. 


### Библиография

#### [Использование семафоров и мьютексов в FreeRTOS на Arduino Uno](https://microkontroller.ru/arduino-projects/ispolzovanie-semaforov-i-myuteksov-v-freertos-na-arduino-uno/)

#### [Watchdogs Esp32 - документация Espressif 5.3.1](https://docs.espressif.com/projects/esp-idf/en/v5.3.1/esp32/api-reference/system/wdts.html) 

#### [Введение в сторожевые таймеры (https://www.embedded.com/introduction-to-watchdog-timers/)](https://www.embedded.com/introduction-to-watchdog-timers/)




###### [в начало](#kvizzy)

0

1

2

3

4

5

6

7

8

9

0

1

2

3

4

5




