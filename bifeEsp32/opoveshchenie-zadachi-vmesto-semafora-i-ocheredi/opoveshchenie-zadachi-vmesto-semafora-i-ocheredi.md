## [Оповещение задачи вместо семафора и очереди](https://github.com/Vladimir-Trufanov/BitofExpert/blob/main/bifeEsp32/vse-pro-sram-pamyat/vse-pro-sram-pamyat.md) [2025-02-09]

Очереди и семафоры - это базовые функции, предоставляемые всеми операционными системами. Разработчики, впервые использующие FreeRTOS, применяют их, потому что они им знакомы. Однако в большинстве случаев ***прямые уведомления о задачах FreeRTOS*** обеспечивают более компактную и на 45% более быструю альтернативу семафорам, а ***буферы сообщений и потоковые буферы FreeRTOS*** обеспечивают более компактную и быструю альтернативу очередям.

> ***Ричард Барри основал проект FreeRTOS в 2003 году, более десяти лет занимался разработкой и продвижением FreeRTOS в своей компании Real Time Engineers Ltd, а сейчас продолжает работать над FreeRTOS в составе большой команды в качестве главного инженера в Amazon Web Services. ***

---

### [Предыстория oт Ричарда Барри](#%D0%BF%D1%80%D0%B5%D0%B4%D1%8B%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F-%D0%BE%D1%82-%D1%80%D0%B8%D1%87%D0%B0%D1%80%D0%B4%D0%B0-%D0%B1%D0%B0%D1%80%D1%80%D0%B8)

### [Как узнать версию FreeRTОS](#%D0%BA%D0%B0%D0%BA-%D1%83%D0%B7%D0%BD%D0%B0%D1%82%D1%8C-%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8E-freertos)

### [Семафорные функции чeрез уведомления](#%D1%81%D0%B5%D0%BC%D0%B0%D1%84%D0%BE%D1%80%D0%BD%D1%8B%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-%D1%83%D0%B2%D0%B5%D0%B4%D0%BE%D0%BC%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F)

### [Передача величин uint32_t через уведомления](#)

---

Каждая задача RTOS имеет массив уведомлений о задачах. Каждое уведомление о задаче имеет состояние уведомления, которое может быть либо 'ожидание', либо 'не ожидание', а также 32-битное значение уведомления. Константа configTASK_NOTIFICATION_ARRAY_ENTRIES устанавливает количество индексов в массиве уведомлений о задачах. До версии FreeRTOS V10.4.0 задачи имели только одно уведомление, а не массив уведомлений.

> Оповещения задач осуществляются через DMA следующим образом:  задача RTOS вызывает передающую функцию, затем ждёт в ,блокированном состоянии (не потребляя время CPU), пока не получит оповещение о завершении передачи. Передача происходит под управлением DMA, а прерывание завершения DMA используется для оповещения задачи.
 
>  Для отправки оповещений используются API-вызовы группы "xTaskNotify" или "xTaskNotifyGive". Оповещения остаются в состоянии ожидания, пока принимающая задача не вызовет их по "xTaskNotifyWait" или "ulTaskNotifyTake".

Прямое уведомление о задаче — это событие, отправляемое непосредственно задаче, а не косвенно через промежуточный объект, такой как очередь, группа событий или семафор. При отправке прямого уведомления о задаче состояние целевого уведомления о задаче устанавливается в «ожидание». Точно так же, как задача может блокироваться на промежуточном объекте, таком как семафор, в ожидании доступности этого семафора, задача может блокироваться на уведомлении о задаче в ожидании перехода этого уведомления в состояние ожидания.

При отправке прямого уведомления о задаче в задачу также можно дополнительно обновить значение целевого уведомления одним из следующих способов:

- перезаписать значение независимо от того, прочитало ли его получающее задание;

- перезаписать значение, но только если получающая задача прочитала перезаписываемое значение;

- установить один или несколько битов в значении;

- увеличить (добавить единицу) значение.

Вызов ***xTaskNotifyWait()/xTaskNotifyWaitIndexed()*** для считывания значения уведомления приводит к тому, что состояние уведомления становится равным 'не ожидающее'. Состояние уведомления также можно явно установить равным 'не ожидающее' с помощью вызова ***xTaskNotifyStateClear()/xTaskNotifyStateClearIndexed()***.

Примечание: каждое уведомление в массиве работает независимо — задача может быть заблокирована только одним уведомлением в массиве за раз и не будет разблокирована уведомлением, отправленным в любой другой индекс массива.

Функция уведомлений о задачах RTOS включена по умолчанию и может быть исключена из сборки (для экономии 5 байт на индекс массива для каждой задачи) путем установки ***configUSE_TASK_NOTIFICATIONS*** в значение ***0*** в ***FreeRTOSConfig.h***.

ВАЖНОЕ ПРИМЕЧАНИЕ: для буферов потоков и сообщений FreeRTOS  использует уведомление о задаче по индексу массива 0. Если требуется сохранить состояние уведомления о задаче при вызове функции API буфера потока или сообщения, следует использовать уведомление о задаче по индексу массива больше 0.

Гибкость уведомлений о задачах позволяет использовать их там, где в противном случае пришлось бы создавать отдельную очередь, двоичный семафор, счетный семафор или группу событий. Разблокировка задачи RTOS с помощью прямого уведомления выполняется на 45% быстрее† и требует меньше оперативной памяти, чем разблокировка задачи с помощью промежуточного объекта, такого как двоичный семафор. Как и следовало ожидать, эти преимущества в производительности требуют некоторых ограничений в использовании:

Уведомления о задачах RTOS можно использовать только в том случае, если существует только одна задача, которая может быть получателем события. Однако это условие выполняется в большинстве реальных случаев использования, например, при прерывании, разблокирующем задачу, которая будет обрабатывать данные, полученные в результате прерывания.

### Предыстория от Ричарда Барри

"*В FreeRTOS, выпущенной в 2002 году, была добавлена функция семафоров за счёт реализации API семафоров в виде набора макросов, которые вызывают API очередей. Преимущество такого подхода заключалось в том, что функция семафоров была добавлена без увеличения размера кода (что было важно, когда объём флэш-памяти обычно был меньше, чем сегодня), но недостатком было то, что семафоры были нетипично тяжёлыми объектами, поскольку они наследовали все функции очереди*.

*Например, очереди по-настоящему учитывают потоки и приоритеты, включают в себя механизм событий и упорядоченные по приоритету списки задач, ожидающих отправки в очередь и получения из очереди. В некоторых случаях использования семафоров эта комплексная функциональность полезна, но в большинстве случаев она не требуется*. 

*Поэтому, когда мы искали простой механизм событий для использования в библиотеках драйверов, мы решили не переписывать код семафоров, а создать новый примитив, специально предназначенный для этих наиболее распространённых случаев использования. Этот примитив* - ***прямые уведомления о задачах*** - *с этого момента будет называться просто **уведомления***".

#### Что такое непосредственное уведомления о задаче?

Большинство методов межзадачной связи проходят через промежуточные объекты, такие как ***очередь, семафор или группа событий***. Отправляющая задача записывает данные в объект связи, а принимающая задача считывает данные из объекта связи. При использовании прямого уведомления о задаче, как следует из названия, отправляющая задача отправляет уведомление непосредственно принимающей задаче без использования промежуточного объекта.

![Коммуникация через объект-посредник](kommunikaciya-cherez-obekt-posrednik.jpg)

![Общение без посреднического объекта](obshchenie-bez-posrednicheskogo-obekta.jpg)

Начиная с FreeRTOS V10.4.0, каждая задача имеет массив уведомлений. До этого у каждой задачи было по одному уведомлению. Каждое уведомление состоит из 32-битного значения и логического состояния, которые вместе занимают всего 5 байт оперативной памяти.

Точно так же, как задача может блокироваться на двоичном семафоре в ожидании, пока этот семафор станет «доступным», задача может блокироваться на уведомлении в ожидании, пока состояние этого уведомления «ожидающее». Точно так же, как задача может блокироваться на счётном семафоре в ожидании, пока счёт этого семафора ненулевой, задача может блокироваться на уведомлении в ожидании, пока значение этого уведомления ненулевое.

###### [к содержанию](#%D0%BF%D1%80%D0%B5%D0%B4%D1%8B%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F-o%D1%82-%D1%80%D0%B8%D1%87%D0%B0%D1%80%D0%B4%D0%B0-%D0%B1%D0%B0%D1%80%D1%80%D0%B8)

---

### Как узнать версию FreeRTOS

Узнать версию FreeRTOS можно по определениям, доступным в файле ***task.h***. Они определяют версию ядра по следующим параметрам: tskKERNEL_VERSION_NUMBER (версия ядра), tskKERNEL_VERSION_MAJOR (основная версия), tskKERNEL_VERSION_MINOR (минорная версия), tskKERNEL_VERSION_BUILD (версия сборки).

```
#include "task.h"

/*-----------------------------------------------------------
 * MACROS AND DEFINITIONS
 *----------------------------------------------------------*/

#define tskKERNEL_VERSION_NUMBER       "V10.4.3"
#define tskKERNEL_VERSION_MAJOR        10
#define tskKERNEL_VERSION_MINOR        4
#define tskKERNEL_VERSION_BUILD        3
```

###### [к содержанию](#%D0%BF%D1%80%D0%B5%D0%B4%D1%8B%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F-o%D1%82-%D1%80%D0%B8%D1%87%D0%B0%D1%80%D0%B4%D0%B0-%D0%B1%D0%B0%D1%80%D1%80%D0%B8)

---

### Семафорные функции через уведомления



###### [к содержанию](#%D0%BF%D1%80%D0%B5%D0%B4%D1%8B%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F-o%D1%82-%D1%80%D0%B8%D1%87%D0%B0%D1%80%D0%B4%D0%B0-%D0%B1%D0%B0%D1%80%D1%80%D0%B8)

---

### Пример использования уведомления для синхронизации прерывания с задачей

В листинге ниже показано приложение с задачей, которая блокируется на уведомлении. Если бы задача блокировалась на семафоре, она бы вызывала функцию xSemaphoreTake() API, но поскольку задача использует уведомление, она вместо этого вызывает функцию ulTaskNotifyTake() API. Функция ulTaskNotifyTake() всегда использует уведомление с индексом 0. Рекомендуется использовать ulTaskNotifyTakeIndexed() вместо ulTaskNotifyTake(), чтобы использовать уведомление по любому конкретному индексу массива.

#### [1 пример]()


### Пример использования уведомления с отправкой значения из задачи в задачу


#### [2 пример]()


### Пример использования уведомления для отправки значения из ISR в задачу

В следующем примере использование уведомлений выходит за рамки простого повторения поведения семафора и демонстрирует, как отправлять данные с помощью уведомлений. Отправка данных требует минимальных дополнительных затрат.

В листинге показана структура функции, которая возвращает результат аналого-цифрового преобразования (АЦП). Задача, которая вызывает функцию, ожидает результат преобразования в заблокированном состоянии, поэтому она не расходует ресурсы процессора. Результат отправляется ей из подпрограммы обработки прерываний (ISR) в конце преобразования. В этом сценарии необходимо использовать несколько более сложные функции API xTaskNotify() и xTaskNotifyWait(). Как и прежде, xTaskNotify() и xTaskNotifyWait() работают с уведомлением по индексу 0 в массиве уведомлений. Используйте xTaskNotifyIndexed() и xTaskNotifyWaitIndexed() для работы с любым конкретным индексом в массиве.

#### [3 пример]()

### Заключение

FreeRTOS — это устоявшийся продукт, который развивался на протяжении почти двух десятилетий и продолжает развиваться, включая дополнительные функции, адаптированные к наиболее распространённым сценариям использования. Эти функции включают уведомления о задачах, буферы сообщений и потоковые буферы.

Разработчикам следует использовать эти адаптированные функции вместо более старых функций FreeRTOS, потому что они меньше по размеру и работают быстрее, но новые разработчики FreeRTOS часто упускают их из виду, потому что эти концепции не описаны в стандартных текстах по ОС. 

Оригинальные функции FreeRTOS по-прежнему будут всегда доступны для покрытия всех вариантов использования, но в большинстве приложений использование комплексных функций, таких как очереди и семафоры, может быть скорее исключением, чем нормой.





### Библиография

#### [RTOS Task Notifications](https://freertos.org/Documentation/02-Kernel/04-API-references/05-Direct-to-task-notifications/00-RTOS-task-notifications)

#### [Уменьшение объема оперативной памяти и ускорение с помощью уведомлений FreeRTOS](https://freertos.org/Community/Blogs/2020/decrease-ram-footprint-and-accelerate-execution-with-freertos-notifications)

#### [FreeRTOS direct to task notifications](https://freertos.org/Documentation/02-Kernel/02-Kernel-features/03-Direct-to-task-notifications/01-Task-notifications)



