/** Arduino-Esp32-CAM                             *** NotificForSynchro.ino ***
 * 
 *              Использовать уведомления для синхронизации прерывания с задачей
 * 
 * v1.0.0, 08.02.2025                                 Автор:      Труфанов В.Е.
 * Copyright © 2025 tve                               Дата создания: 08.02.2025
 * 
 * SETUP отработал!
 * Задача запустилась 1 раз
 * Задача получила уведомление!
 * Задача запустилась 2 раз
 * Задача получила уведомление!
 * Задача запустилась 3 раз
 * Задача получила уведомление!
 * ...
**/

// Определяем заголовок для объекта таймера
hw_timer_t *timer = NULL;

/* This is an example of a transmit function in a generic peripheral driver. An  
   RTOS task calls the transmit function, then waits in the Blocked state (so not  
   using an CPU time) until it is notified that the transmission is complete. The  
   transmission is performed by a DMA, and the DMA end interrupt is used to notify  
   the task. */  
static TaskHandle_t xTaskToNotify = NULL;  


// ****************************************************************************
// *                          Инициировать приложение                         *
// ****************************************************************************
void setup() 
{
   Serial.begin(115200);
   // Определяем задачу
   xTaskCreatePinnedToCore (
      vNotifiedTask,   // название функции, которая будет запускаться, как задача
      "Сообщение",     // название задачи
      1024,            // размер стека в байтах
      NULL,            // указатель параметра, который будет передан задаче (NULL, если параметр не передаётся)
      0,               // приоритет задачи
      &xTaskToNotify,  // дескриптор или указатель на задачу
      0                // ядро процессора, на котором требуется запустить задачу 
   );
   // Создаём объект таймера, устанавливаем его частоту отсчёта (1Mhz)
   timer = timerBegin(1000000);
   // Подключаем функцию обработчика прерывания от таймера - onTimer
   timerAttachInterrupt(timer, &onTimer);
   // Настраиваем таймер: интервал перезапуска - 3 секунды (3000000 микросекунд),
   // всегда повторяем перезапуск (третий параметр = true), неограниченное число 
   // раз (четвертый параметр = 0) 
   timerAlarm(timer, 3000000, true, 0);
   Serial.println("SETUP отработал ggg!");
}

/*
// Определяем структуру передаваемого сообщения
struct AMessage
{
   int  ucSize;        // Длина сообщения (максимально 256 байт)
   char ucData[256];   // Текст сообщения
};
// Создаем структуру для передачи сообщения из задачи и указатель на нее   
struct AMessage xMessage, *pxMessage;
// Создаем структуру для приёма сообщений   
struct AMessage xRxedStructure;
// Определяем очередь сообщений
QueueHandle_t xQueue;
// Инициируем счетчик циклов дополнительной задачи
unsigned long nLoop = 0UL;
// ****************************************************************************
// *  Сформировать сообщение о прошедшем времени с начала запуска приложения  *
// *                        И ПЕРЕДАТЬ ЧЕРЕЗ ПРЕРЫВАНИЕ                       *
// ****************************************************************************
// Определяем заголовок для объекта таймера
hw_timer_t *timer = NULL;
// Выделяем и инициируем переменную для прошлого момента времени
int lastMillis = millis(); 

void ARDUINO_ISR_ATTR onTimer() 
{
   // Размещаем структуру для сообщения в статической памяти для того,
   // чтобы уменьшить фрагментацию кучи 
   static DRAM_ATTR struct AMessage xiMessage;
   // Выделяем переменную планировщикe задач FreeRTOS для указания
   // необходимости переключения после прерывания на более приоритетную 
   // задачу, связанную с очередью
   static DRAM_ATTR BaseType_t xHigherPriorityTaskWoken;
   // Выделяем переменную для текущего момента времени
   static DRAM_ATTR int currMillis;
   // Выделяем переменную для прошедшего времени с начала запуска приложения
   static DRAM_ATTR int timeMillis;
    
   // Если в очереди есть место, будем размещать сообщение
   if (xQueue!=0)
   {
      // Сбрасываем признак переключения на более приоритетную задачу
      // после прерывания 
      xHigherPriorityTaskWoken = pdFALSE;
      // Определяем время, прошедшее с начала запуска приложения
      currMillis = millis(); 
      if (currMillis < lastMillis) lastMillis=0;
      timeMillis=currMillis-lastMillis;
      // Формируем сообщение для передачи в очередь
      sprintf(xiMessage.ucData, "Прошло %d миллисекунд",timeMillis);
      xiMessage.ucSize = 0;
      while (xiMessage.ucData[xiMessage.ucSize]>0) 
      {
         xiMessage.ucSize++;
      }
      // Отправляем сообщение в структуре AMessage 
      if (xQueueSendFromISR(xQueue, &xiMessage, &xHigherPriorityTaskWoken) != pdPASS)
      {
         Serial.println("ISR: Не удалось отправить структуру!");
      }
   }
   else 
   {
      Serial.println("ISR: Очередь для структур не создана!");
   }
   // Если требуется отдать управление планировщику на переключение 
   // после прерывания на более приоритетную задачу, делаем это 
   if (xHigherPriorityTaskWoken)
   {
      Serial.println("ISR: Управление передаётся планировщику!");
      portYIELD_FROM_ISR();
   }
}
*/

// ****************************************************************************
// *                 Отправить уведомление задаче из прерывания               *
// ****************************************************************************
//static uint32_t vNotifyingISR(void)  

void ARDUINO_ISR_ATTR onTimer() 
{
   // Параметр xHigherPriorityTaskWoken инициализируем значением pdFALSE, 
   // поскольку он будет установлен в значение pdTRUE внутри прерывания с 
   // помощью функции API. Ситуация будет безопасной для прерывания, если вызов 
   // функции API разблокирует задачу, имеющую более высокий приоритет, чем 
   // задача, которую прервала эта ISR
   BaseType_t xHigherPriorityTaskWoken;  
   xHigherPriorityTaskWoken = pdFALSE;  
   // Отправляем уведомление непосредственно задаче, которая выполняет
   // некоторую обработку, связанную с этим прерыванием. В первом параметре 
   // указываем дескриптор задачи, которой отправляется уведомление
   vTaskNotifyGiveFromISR(xTaskToNotify, &xHigherPriorityTaskWoken);
   // Так как xHigherPriorityTaskWoken теперь pdTRUE, то вызов 
   // portYIELD_FROM_ISR() приведет к переключению контекста и это прерывание 
   // вернется непосредственно к разблокированной задаче
    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );  
}  
// ****************************************************************************
// *                    Выполнить основной цикл приложения                    *
// ****************************************************************************
void loop() 
{
   delay(1300);
}
// ****************************************************************************
// * Задача, которая блокируется на уведомлении. Если бы задача блокировалась *
// * на семафоре, она бы вызывала функцию API xSemaphoreTake(), но поскольку  *
// *   задача использует уведомление, она вместо этого вызывает функцию API   *
// *     ulTaskNotifyTake(). Функция ulTaskNotifyTake() всегда использует     *
// *     уведомление с индексом 0. Чтобы использовать уведомление с любым     *
// *            конкретным индексом массива, используйте функцию              *
// *           ulTaskNotifyTakeIndexed() вместо ulTaskNotifyTake()            *
// ****************************************************************************
int i=0;
static void vNotifiedTask(void *pvParameters)  
{  
   for( ;; )  
   {  
      i++;
      Serial.print("Задача запустилась "); Serial.print(i); Serial.println(" раз");
      
      // Ждём получения уведомления, отправленного непосредственно в эту задачу.   
      // Для первого параметра задано значение false, что позволяет выполнить 
      // вызов, повторяющий поведение счетного семафора. Следует установить для 
      // параметра значение true для воспроизведения поведения двоичного семафора   
      // Второму параметру присвоено значение port MAX_DELAY, что заставляет задачу 
      // блокироваться на неопределенный срок в ожидании уведомления. 
      // Это сделано для упрощения примера, реальные приложения не должны 
      // блокироваться на неопределенный срок, поскольку это не даёт задаче   
      // восстанавливается после ошибок.
      if (ulTaskNotifyTake(pdFALSE, portMAX_DELAY) != 0)  
      {  
         // Как только задача получит уведомление, то 
         // обрабатываем полученное событие
         DoSomething();  
      }  
   }  
}  
// ****************************************************************************
// *                    Выполнить основной цикл приложения                    *
// ****************************************************************************
void DoSomething() 
{
   Serial.println("Задача получила уведомление!");
}

// ************************************************** NotificForSynchro.ino ***
