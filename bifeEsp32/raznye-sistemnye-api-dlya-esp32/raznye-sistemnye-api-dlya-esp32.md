## [Разные системные API для ESP32](#)

### [Miscellaneous System APIs](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/misc_system_api.html#_CPPv411esp_restartv)

#### Сброс программного обеспечения

Для выполнения программного сброса чипа предусмотрена функция ***esp_restart()***. При вызове функции выполнение программы останавливается, оба процессора сбрасываются, приложение загружается загрузчиком и снова начинает выполнение.

Кроме того, ***esp_register_shutdown_handler()*** функция может зарегистрировать процедуру, которая будет автоматически вызываться перед перезапуском (который запускается esp_restart()). 

[void esp_restart(void)]()

Перезапустить процессоры PRO и APP.

> *PRO и APP - так называются два ядра: core 0 - PRO, core 1 - APP.*
> 
> *Это устаревшие названия. Первоначальный дизайн ESP32 предусматривал асимметричную многопроцессорную настройку, при которой в CPU0 запускался весь код обработки протокола, в то время как приложение работало бы на CPU1. Позже мы изменили это на симметричную многопроцессорную настройку, и на данный момент два процессора (за очень немногими небольшими исключениями) полностью взаимозаменяемы.*
> 
> *Опции, которые вы можете использовать для перемещения различных системных задач между двумя ядрами:*
> 
> *CONFIG_BTDM_CONTROLLER_PINNED_TO_CORE_CHOICE*
> 
> *CONFIG_BLUEDROID_PINNED_TO_CORE_CHOICE*
> 
> *CONFIG_TCPIP_TASK_AFFINITY*
> 
> *CONFIG_ESP32_WIFI_TASK_CORE_ID*
>

Эта функция может вызываться как с процессоров PRO, так и с процессоров APP. После успешного перезапуска причиной сброса процессора будет SW_CPU_RESET. Периферийные устройства (за исключением Wi-Fi, BT, UART0, SPI1 и устаревших таймеров) не сбрасываются. Значение функцией не возвращается.

[esp_reset_reason_t esp_reset_reason(void)]()

Получить причину последнего сброса. Возвращается ***esp_reset_reason_t***:

```
enumerator ESP_RST_UNKNOWN
Невозможно определить причину сброса.

enumerator ESP_RST_POWERON
Сброс из-за события включения питания.

enumerator ESP_RST_EXT
Сброс с помощью внешнего PIN-кода (не применимо для ESP32)

enumerator ESP_RST_SW
Сброс программного обеспечения через esp_restart.

enumerator ESP_RST_PANIC
Сброс программного обеспечения из-за исключения / паники.

enumerator ESP_RST_INT_WDT
Сброс (программный или аппаратный) из-за сторожевого таймера прерывания.

enumerator ESP_RST_TASK_WDT
Сброс из-за диспетчера задач.

enumerator ESP_RST_WDT
Сброс из-за других сторожевых псов.

enumerator ESP_RST_DEEPSLEEP
Сброс после выхода из режима глубокого сна.

enumerator ESP_RST_BROWNOUT
Сброс отключения (программный или аппаратный)

enumerator ESP_RST_SDIO
Сброс через SDIO.

enumerator ESP_RST_USB
Сброс с помощью периферийного устройства USB.

enumerator ESP_RST_JTAG
Сброс с помощью JTAG.

enumerator ESP_RST_EFUSE
Сброс из-за ошибки efuse.

enumerator ESP_RST_PWR_GLITCH
Сброс из-за обнаруженного сбоя питания.

enumerator ESP_RST_CPU_LOCKUP
Сброс из-за блокировки процессора.
```

#### А что с PROGMEM?

На Arduino макросы препроцессора PROGMEM, PSTR и F заставляют компоновщик изменять место хранения переменной в программе. Например PROGMEM помещает переменную во FLASH память. А что с ними на ESP32?

> А на ESP32 макросы PROGMEM, PSTR и F отсутствуют!

В avr-gcc все данные (в том числе и static const) по умолчанию размещаются в SRAM. А так как размер RAM в avr очень маленький, то использовался атрибут PROGMEM, который позволял разместить static const данные во flash (но при этом при непосредственном использовании все равно происходило копирование в SRAM – pgm_read….).

В ESP32 весь код по умолчанию размещается уже в external flash, кроме того в external flash размещаются все static const данные (при этом обращение к этим данным происходит непосредственно без всяких pgm_read), и таким образом атрибут PROGMEM становится ненужным.

Однако возникает противоположная проблема – в определенных режимах (например в обработчиках прерываний и т.д.) external flash недоступен, поэтому код, который работает в таких режимах должен быть размещен в SRAM (конкретно в IRAM). Для этого используется атрибут IRAM_ATTR. Код функций помеченный этим аттрибутом, будет размещен в IRAM. 

Однако размещение кода в IRAM не гарантирует также и размещение данных в RAM, т.е. например если внутри функции помеченной атрибутом IRAM_ATTR у нас будет static const массив, то этот массив компилятор все равно сможет разместить в external flash. Для того чтобы этого избежать и явно указать компилятору что static const данные нужно тоже размещать в RAM (конкретно в DRAM) используется атрибут DRAM_ATTR.

> ***Все доступные для ESP32 атрибуты размещены в файле esp_attr.h***


### [ESP32Ping](https://github.com/marian-craciunescu/ESP32Ping)

---


Обратите внимание, что я использую [макрос ведения журнала, log_d(..)](https://thingpulse.com/esp32-logging/) который позволяет нам позже отключить вывод журнала. Если мы запустим этот код в Arduino IDE со следующими настройками в меню инструментов. Особенно убедитесь, что ***для основного уровня отладки установлено значение Verbose***.



---