## [оповещения задач](https://github.com/Vladimir-Trufanov/BitofExpert/blob/main/bifeEsp32/vse-pro-sram-pamyat/vse-pro-sram-pamyat.md) [2025-02-08]

### Как узнать версию FreeRTOS

Узнать версию FreeRTOS можно по определениям, доступным в файле ***task.h***. Они определяют версию ядра по следующим параметрам: tskKERNEL_VERSION_NUMBER (версия ядра), tskKERNEL_VERSION_MAJOR (основная версия), tskKERNEL_VERSION_MINOR (минорная версия), tskKERNEL_VERSION_BUILD (версия сборки).

```
#include "task.h"

/*-----------------------------------------------------------
 * MACROS AND DEFINITIONS
 *----------------------------------------------------------*/

#define tskKERNEL_VERSION_NUMBER       "V10.4.3"
#define tskKERNEL_VERSION_MAJOR        10
#define tskKERNEL_VERSION_MINOR        4
#define tskKERNEL_VERSION_BUILD        3
```

> ***Ричард Барри основал проект FreeRTOS в 2003 году, более десяти лет занимался разработкой и продвижением FreeRTOS в своей компании Real Time Engineers Ltd, а сейчас продолжает работать над FreeRTOS в составе большой команды в качестве главного инженера в Amazon Web Services. ***

### [Уменьшение объема оперативной памяти и ускорение с помощью уведомлений FreeRTOS](https://freertos.org/Community/Blogs/2020/decrease-ram-footprint-and-accelerate-execution-with-freertos-notifications)

Очереди и семафоры - это базовые функции, предоставляемые всеми операционными системами. Разработчики, впервые использующие FreeRTOS, применяют их, потому что они им знакомы. Однако в большинстве случаев ***прямые уведомления о задачах FreeRTOS*** обеспечивают более компактную и на 45% более быструю альтернативу семафорам, а ***буферы сообщений и потоковые буферы FreeRTOS*** обеспечивают более компактную и быструю альтернативу очередям.

#### Предыстория от Ричард Барри

"*В FreeRTOS, выпущенной в 2002 году, была добавлена функция семафоров за счёт реализации API семафоров в виде набора макросов, которые вызывают API очередей. Преимущество такого подхода заключалось в том, что функция семафоров была добавлена без увеличения размера кода (что было важно, когда объём флэш-памяти обычно был меньше, чем сегодня), но недостатком было то, что семафоры были нетипично тяжёлыми объектами, поскольку они наследовали все функции очереди*.

*Например, очереди по-настоящему учитывают потоки и приоритеты, включают в себя механизм событий и упорядоченные по приоритету списки задач, ожидающих отправки в очередь и получения из очереди. В некоторых случаях использования семафоров эта комплексная функциональность полезна, но в большинстве случаев она не требуется*. 

*Поэтому, когда мы искали простой механизм событий для использования в библиотеках драйверов, мы решили не переписывать код семафоров, а создать новый примитив, специально предназначенный для этих наиболее распространённых случаев использования. Этот примитив* - ***прямые уведомления о задачах*** - *с этого момента будет называться просто **уведомления***".

#### Что такое непосредственное уведомления о задаче?

Большинство методов межзадачной связи проходят через промежуточные объекты, такие как ***очередь, семафор или группа событий***. Отправляющая задача записывает данные в объект связи, а принимающая задача считывает данные из объекта связи. При использовании прямого уведомления о задаче, как следует из названия, отправляющая задача отправляет уведомление непосредственно принимающей задаче без использования промежуточного объекта.

![Коммуникация через объект-посредник](kommunikaciya-cherez-obekt-posrednik.jpg)

![Общение без посреднического объекта](obshchenie-bez-posrednicheskogo-obekta.jpg)

Начиная с FreeRTOS V10.4.0, каждая задача имеет массив уведомлений. До этого у каждой задачи было по одному уведомлению. Каждое уведомление состоит из 32-битного значения и логического состояния, которые вместе занимают всего 5 байт оперативной памяти.

Точно так же, как задача может блокироваться на двоичном семафоре в ожидании, пока этот семафор станет «доступным», задача может блокироваться на уведомлении в ожидании, пока состояние этого уведомления «ожидающее». Точно так же, как задача может блокироваться на счётном семафоре в ожидании, пока счёт этого семафора ненулевой, задача может блокироваться на уведомлении в ожидании, пока значение этого уведомления ненулевое. Первый пример ниже демонстрирует этот сценарий.

### Пример использования уведомления для синхронизации прерывания с задачей

В листинге ниже показано приложение с задачей, которая блокируется на уведомлении. Если бы задача блокировалась на семафоре, она бы вызывала функцию xSemaphoreTake() API, но поскольку задача использует уведомление, она вместо этого вызывает функцию ulTaskNotifyTake() API. Функция ulTaskNotifyTake() всегда использует уведомление с индексом 0. Рекомендуется использовать ulTaskNotifyTakeIndexed() вместо ulTaskNotifyTake(), чтобы использовать уведомление по любому конкретному индексу массива.

#### [1 пример]()


### Пример использования уведомления с отправкой значения из задачи в задачу


#### [2 пример]()


### Пример использования уведомления для отправки значения из ISR в задачу

В следующем примере использование уведомлений выходит за рамки простого повторения поведения семафора и демонстрирует, как отправлять данные с помощью уведомлений. Отправка данных требует минимальных дополнительных затрат.

В листинге показана структура функции, которая возвращает результат аналого-цифрового преобразования (АЦП). Задача, которая вызывает функцию, ожидает результат преобразования в заблокированном состоянии, поэтому она не расходует ресурсы процессора. Результат отправляется ей из подпрограммы обработки прерываний (ISR) в конце преобразования. В этом сценарии необходимо использовать несколько более сложные функции API xTaskNotify() и xTaskNotifyWait(). Как и прежде, xTaskNotify() и xTaskNotifyWait() работают с уведомлением по индексу 0 в массиве уведомлений. Используйте xTaskNotifyIndexed() и xTaskNotifyWaitIndexed() для работы с любым конкретным индексом в массиве.

#### [3 пример]()

### Заключение

FreeRTOS — это устоявшийся продукт, который развивался на протяжении почти двух десятилетий и продолжает развиваться, включая дополнительные функции, адаптированные к наиболее распространённым сценариям использования. Эти функции включают уведомления о задачах, буферы сообщений и потоковые буферы.

Разработчикам следует использовать эти адаптированные функции вместо более старых функций FreeRTOS, потому что они меньше по размеру и работают быстрее, но новые разработчики FreeRTOS часто упускают их из виду, потому что эти концепции не описаны в стандартных текстах по ОС. 

Оригинальные функции FreeRTOS по-прежнему будут всегда доступны для покрытия всех вариантов использования, но в большинстве приложений использование комплексных функций, таких как очереди и семафоры, может быть скорее исключением, чем нормой.





### Библиография

#### [FreeRTOS direct to task notifications](https://freertos.org/Documentation/02-Kernel/02-Kernel-features/03-Direct-to-task-notifications/01-Task-notifications)

#### [RTOS Task Notifications](https://freertos.org/Documentation/02-Kernel/04-API-references/05-Direct-to-task-notifications/00-RTOS-task-notifications)



